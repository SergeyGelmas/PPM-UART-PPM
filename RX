#define PPM_OUT_PIN PB1
#define NUM_CHANNELS 8
#define LED_PIN PC13

uint16_t channels[NUM_CHANNELS] = {1500,1500,1500,1500,1500,1500,1500,1500};
const uint16_t failsafeChannels[NUM_CHANNELS] = {1000,1500,1500,1500,1500,1500,1500,1500};

const uint16_t frameLength = 22500; // мкс
const uint16_t pulseLength = 300;   // мкс

uint32_t lastGoodPacket = 0;
bool ledState = false;

void setup() {
  Serial1.begin(115200);
  pinMode(PPM_OUT_PIN, OUTPUT);
  digitalWrite(PPM_OUT_PIN, HIGH);

  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, HIGH); // Выключено (на STM32 PC13 инверсный)
}

void loop() {
  static uint8_t state = 0;
  static uint8_t data[16];
  static uint8_t idx = 0;
  static uint8_t checksum = 0;
  static uint32_t lastErrorBlink = 0;

  while (Serial1.available()) {
    uint8_t b = Serial1.read();

    switch (state) {
      case 0: if (b == 0xFF) state = 1; break;
      case 1: if (b == 0xFE) { state = 2; idx = 0; checksum = 0; } else state = 0; break;
      case 2:
        data[idx++] = b;
        checksum ^= b;
        if (idx >= 16) state = 3;
        break;
      case 3:
        if (checksum == b) {
          for (uint8_t i = 0; i < NUM_CHANNELS; i++) {
            channels[i] = data[i * 2] | (data[i * 2 + 1] << 8);
          }
          lastGoodPacket = millis();
        } else {
          if (millis() - lastErrorBlink > 100) {
            digitalWrite(LED_PIN, !digitalRead(LED_PIN));
            lastErrorBlink = millis();
          }
        }
        state = 0;
        break;
    }
  }

  // Выбор источника для генерации PPM: актуальные данные или failsafe
  uint16_t *activeChannels;
  if (millis() - lastGoodPacket > 300) {
    activeChannels = (uint16_t*)failsafeChannels;
  } else {
    activeChannels = channels;
  }

  // Генерация PPM
  uint32_t start = micros();
  for (uint8_t i = 0; i < NUM_CHANNELS; i++) {
    digitalWrite(PPM_OUT_PIN, LOW);
    delayMicroseconds(pulseLength);
    digitalWrite(PPM_OUT_PIN, HIGH);
    delayMicroseconds(activeChannels[i] - pulseLength);
  }

  uint32_t elapsed = micros() - start;
  if (elapsed < frameLength) {
    digitalWrite(PPM_OUT_PIN, LOW);
    delayMicroseconds(pulseLength);
    digitalWrite(PPM_OUT_PIN, HIGH);
    delayMicroseconds(frameLength - elapsed - pulseLength);
  }

  // Индикация статуса
  if (millis() - lastGoodPacket > 1000) {
    // Потеря связи — постоянно включённый LED
    digitalWrite(LED_PIN, LOW);
  } else {
    // Связь есть — мигаем раз в 1 с
    static uint32_t lastBlink = 0;
    if (millis() - lastBlink > 1000) {
      ledState = !ledState;
      digitalWrite(LED_PIN, ledState ? LOW : HIGH);
      lastBlink = millis();
    }
  }
}
